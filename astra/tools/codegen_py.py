"""Astra -> Python code generator.

Design goals:
- Deterministic output (stable diffs)
- Generated code uses a string-based dispatch (`_CALL`) to avoid Python keyword
  conflicts (e.g. calling Astra builtin "and").
- When executed via `astra run-py`, the code is executed with restricted globals
  and an effect allowlist enforced by `runtime_guarded`.

This generator is not trying to generate the most idiomatic Python, but the
safest/most predictable.
"""

from __future__ import annotations

import argparse
import json
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional


def _qual_last(name: str) -> str:
    return name.rsplit(".", 1)[-1]


def _lit(v: Any) -> str:
    # Use json.dumps for stable literals.
    return json.dumps(v, ensure_ascii=False)


def _gen_expr(expr: Any) -> str:
    if isinstance(expr, (int, float, str, bool)) or expr is None:
        return _lit(expr)
    if not isinstance(expr, dict):
        return _lit(None)

    if "var" in expr:
        return expr["var"]

    if "list" in expr:
        return "[" + ", ".join(_gen_expr(x) for x in expr["list"]) + "]"

    if "obj" in expr:
        items = []
        for k in sorted(expr["obj"].keys()):
            items.append(f"{_lit(k)}: {_gen_expr(expr['obj'][k])}")
        return "{" + ", ".join(items) + "}"

    if "call" in expr:
        call = expr["call"]
        fn = call.get("fn", "")
        args = call.get("args", []) or []
        return "_CALL(" + _lit(fn) + ("" if not args else ", " + ", ".join(_gen_expr(a) for a in args)) + ")"

    return _lit(None)


def _indent(lines: List[str], n: int) -> List[str]:
    pad = " " * n
    return [pad + l if l else l for l in lines]


def _gen_stmt(stmt: Any, indent: int = 0) -> List[str]:
    if not isinstance(stmt, dict) or len(stmt.keys()) != 1:
        return _indent(["# <invalid stmt>"], indent)

    tag = next(iter(stmt.keys()))
    val = stmt[tag]

    if tag == "let":
        name = val.get("name", "_")
        expr = _gen_expr(val.get("expr"))
        return _indent([f"{name} = {expr}"], indent)

    if tag == "expr":
        return _indent([_gen_expr(val)], indent)

    if tag == "assert":
        expr = _gen_expr(val.get("expr"))
        msg = val.get("message")
        if isinstance(msg, str):
            return _indent([f"assert {expr}, {_lit(msg)}"], indent)
        return _indent([f"assert {expr}"], indent)

    if tag == "return":
        return _indent([f"return {_gen_expr(val)}"], indent)

    if tag == "if":
        cond = _gen_expr(val.get("cond"))
        then = val.get("then", []) or []
        els = val.get("else", []) or []
        out: List[str] = []
        out.extend(_indent([f"if {cond}:"] , indent))
        then_lines: List[str] = []
        for s in then:
            then_lines.extend(_gen_stmt(s, indent + 2))
        if not then_lines:
            then_lines = _indent(["pass"], indent + 2)
        out.extend(then_lines)
        out.extend(_indent(["else:"], indent))
        else_lines: List[str] = []
        for s in els:
            else_lines.extend(_gen_stmt(s, indent + 2))
        if not else_lines:
            else_lines = _indent(["pass"], indent + 2)
        out.extend(else_lines)
        return out

    return _indent([f"# <unknown stmt {tag}>"], indent)


def generate_python(module: Dict[str, Any], *, standalone: bool = True) -> str:
    lines: List[str] = []
    lines.append("# Generated by Astra codegen (v1.0)")
    if standalone:
        lines.append("from astra.tools import runtime_guarded as rt")
    lines.append("")
    lines.append("def _CALL(fn, *args):")
    lines.append("  name = fn.rsplit('.', 1)[-1]")
    lines.append("  if name in rt.BUILTINS:")
    lines.append("    return rt.call_builtin(name, list(args))")
    lines.append("  f = globals().get(name)")
    lines.append("  if f is None:")
    lines.append("    raise NameError(f'Unknown function: {name}')")
    lines.append("  return f(*args)")
    lines.append("")

    # Enable higher-order builtins (list_map/list_filter/list_reduce) in generated code.
    # runtime_guarded builtins call back into this dispatcher to invoke user functions.
    lines.append("def _DISPATCH(fn, args):")
    lines.append("  return _CALL(fn, *args)")
    lines.append("rt.set_dispatch(_DISPATCH)")
    lines.append("")

    for fn in module.get("functions", []) or []:
        if not isinstance(fn, dict) or not isinstance(fn.get("name"), str):
            continue
        name = fn["name"]
        params = [p for p in (fn.get("params", []) or []) if isinstance(p, str)]
        lines.append(f"def {name}({', '.join(params)}):")
        body = fn.get("body", []) or []
        if not isinstance(body, list) or not body:
            lines.append("  return None")
            lines.append("")
            continue
        body_lines: List[str] = []
        for s in body:
            body_lines.extend(_gen_stmt(s, 2))
        if not body_lines:
            body_lines = ["  pass"]
        lines.extend(body_lines)
        lines.append("")

    return "\n".join(lines) + "\n"


def main(argv: Optional[List[str]] = None) -> int:
    ap = argparse.ArgumentParser(prog="astra codegen")
    ap.add_argument("path", help="Path to Astra module JSON")
    ap.add_argument("--out", help="Write generated Python to file (default: stdout)")
    ap.add_argument("--no-standalone", action="store_true", help="Do not emit import rt; expect rt provided")
    args = ap.parse_args(argv)

    try:
        module = json.loads(Path(args.path).read_text(encoding="utf-8"))
    except Exception as e:
        print(f"Failed to read/parse JSON: {e}", file=sys.stderr)
        return 3

    text = generate_python(module, standalone=not args.no_standalone)
    if args.out:
        Path(args.out).write_text(text, encoding="utf-8")
    else:
        sys.stdout.write(text)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
